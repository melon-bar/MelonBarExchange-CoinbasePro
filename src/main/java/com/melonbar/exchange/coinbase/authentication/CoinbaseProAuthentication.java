package com.melonbar.exchange.coinbase.authentication;

import com.melonbar.exchange.coinbase.util.Format;
import com.melonbar.exchange.coinbase.util.Guard;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.joda.time.DateTime;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.net.http.HttpRequest;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

/**
 * Authentication source for making <code>Trade</code> level permission requests to Coinbase Pro.
 */
@Slf4j
@RequiredArgsConstructor
public class CoinbaseProAuthentication implements Authentication {

    private final String apiKey;
    private final String apiPassword;
    private final String apiSecretKey;

    private static final String HMAC_SHA256 = "HmacSHA256";
    private static final String CONTENT_TYPE = "Content-Type";
    private static final String APPLICATION_JSON_TYPE = "application/json";

    private static final String CB_ACCESS_KEY = "CB-ACCESS-KEY";
    private static final String CB_ACCESS_SIGN = "CB-ACCESS-SIGN";
    private static final String CB_ACCESS_TIMESTAMP = "CB-ACCESS-TIMESTAMP";
    private static final String CB_ACCESS_PASSPHRASE = "CB-ACCESS-PASSPHRASE";

    /**
     * Enriches a provided HTTP request builder with necessary headers for making HTTP requests to
     * Coinbase Pro.
     *
     * <p> Note that this authentication source is implemented for API credentials with <code>Trade</code>
     * level permissions. In addition, it should not matter when this enrichment step for authentication
     * occurs for HTTP requests. For example, one could enrich a newly-instantiated {@link HttpRequest.Builder},
     * or enrich as the last step.
     *
     * @param httpRequestBuilder {@link HttpRequest.Builder}
     * @param method HTTP request method, e.g. <code>POST</code>
     * @param requestPath Request path
     * @param body  Nullable message body, automatically converted to empty string for
     *              HTTP <code>GET</code> or null body input
     * @return Signed {@link HttpRequest.Builder}, same reference as input <code>httpRequestBuilder</code>
     * @see <a href="https://docs.pro.coinbase.com/#generating-an-api-key">
     * https://docs.pro.coinbase.com/#generating-an-api-key</a>
     */
    @Override
    public HttpRequest.Builder sign(final HttpRequest.Builder httpRequestBuilder,
                                    final String method,
                                    final String requestPath,
                                    final String body) {
        Guard.nonNull(httpRequestBuilder, method, requestPath, body);
        final String timestamp = Long.toString(DateTime.now().getMillis() / 1000);
        try {
            return httpRequestBuilder
                    .setHeader(CONTENT_TYPE, APPLICATION_JSON_TYPE)
                    .setHeader(CB_ACCESS_KEY, apiKey)
                    .setHeader(CB_ACCESS_PASSPHRASE, apiPassword)
                    .setHeader(CB_ACCESS_TIMESTAMP, timestamp)
                    .setHeader(CB_ACCESS_SIGN, sign(timestamp, method, requestPath, body));
        } catch (NoSuchAlgorithmException | InvalidKeyException exceptionOnSign) {
            // signing issue
            throw new RuntimeException(
                    "Exception thrown while signing HTTP request, " + requestDetails(method, requestPath, body),
                    exceptionOnSign);
        } catch (Exception exception) {
            // other issue
            throw new RuntimeException(
                    "Unexpected runtime exception during creation of HTTP request, "
                            + requestDetails(method, requestPath, body),
                    exception);
        }
    }

    /**
     * Helper method for creating the base64-encoded signed header for <code>CB-ACCESS-SIGN</code>.
     * This header is generated by creating a sha256 HMAC using the base64-decoded secret key on the
     * prehash string <code>timestamp + method + request path + body</code> and base64-encode the output.
     * The timestamp value is the same as the <code>CB-ACCESS-TIMESTAMP</code>> header.
     *
     * <p> The body is the request body string or omitted if there is no request body (typically for
     * <code>GET</code>requests). It is the caller's responsibility to ensure this.
     *
     * @param timestamp Timestamp of request creation
     * @param method HTTP method type
     * @param requestPath Request path
     * @param body Request body, must be empty for <code>GET</code> requests
     * @return Signed header
     * @throws NoSuchAlgorithmException When HMAC is initialized with an invalid Key spec.
     * @throws InvalidKeyException      When an invalid MAC algorithm is provided.
     */
    private String sign(final String timestamp,
                        final String method,
                        final String requestPath,
                        final String body) throws NoSuchAlgorithmException, InvalidKeyException {
        final byte[] decodedSecretKey = Base64.getDecoder().decode(apiSecretKey);
        final Mac hmac = Mac.getInstance(HMAC_SHA256);
        final SecretKeySpec secretKeySpec = new SecretKeySpec(decodedSecretKey, hmac.getAlgorithm());

        // init with secret key spec, made from base64 decoded secret key using sha256 HMAC.
        hmac.init(secretKeySpec);
        return Base64.getEncoder().encodeToString(
                hmac.doFinal((timestamp + method + requestPath + body).getBytes(StandardCharsets.UTF_8)));
    }

    private String requestDetails(final String method, final String uriPath, final String body) {
        return Format.format("method: [{}], URI: [{}], body: [{}]",
                method, uriPath, body);
    }
}
